theory ADEM
begin

heuristic: o "./oracle.py"

builtins: signing

// DNS
rule DomainRegister:
  [ DomainRegister($A, d) ]
  --[ OnlyOnce(<'domain_register', d>)
    , NoTuple(d) ]->
  [ !DomainOwner($A, d), Out(d) ]

restriction NoTuple:
  "All m #t. NoTuple(m) @ #t ==> (not Ex l r. m = <l, r>)"

rule SubdomainRegister:
  [ DomainRegister($A, <d, sub>), !DomainOwner($A, d) ]
  --[ OnlyOnce(<'domain_register', <d, sub>>) ]->
  [ !DomainOwner($A, <d, sub>), Out(<d, sub>) ]

rule DomainCompromise:
  [ !DomainOwner($A, d) ]
  --[ CompromisedDomain(d) ]->
  [ !DomainCompromised(d) ]

// Certificate Transparency
rule LogRegister:
  []
  --[ IsLog($Log) ]->
  [ !Log($Log) ]

rule Submit:
  let certBody = <'cert', $CA, d, pk>
  in
  [ !CA($CA, skCA), !Log($Log)
  , In(<certBody, certSig>) ]
  --[ Eq(verify(certSig, certBody, pk(skCA)), true)
    , Eq(fst(snd(certBody)), $CA)
    , LogInclusion($Log, <certBody, certSig>) ]->
  [ !MHTLeaf($Log, <certBody, certSig>) ]

rule AdversarialAppend:
  [ In(msg) ]
  --[ LogInclusion($Log, msg)
    , CompromisedParty($Log) ]->
  [ !MHTLeaf($Log, msg) ]

// Certificate authorities
rule CA:
  [ Fr(~skCA) ]
  --[ CASk($CA, ~skCA)
    , OnlyOnce(<'CA', $CA>) ]->
  [ !CA($CA, ~skCA), Out(pk(~skCA)) ]

rule FraudulentCertificate:
  [ !CA($CA, ~skCA), In(m) ]
  --[ SigningOracleCA($CA, m)
    , CompromisedCA($CA)
    , CompromisedParty($CA) ]->
  [ Out(<m, sign(m, ~skCA)>) ]

rule TLSKeyRegister:
  [ !DomainOwner($A, d), !CA($CA, skCA), Fr(~skUser) ]
  --[ OnlyOnce(<'tls_key', d>) ]->
  [ !TLSKey($A, $CA, d, ~skUser), Out(pk(~skUser)) ]

rule TLSKeyShare:
  [ !TLSKey($A, $CA, d1, ~skUser), !DomainOwner($A, d2) ]
  --[ OnlyOnce(<'tls_key', d2>)
    , Eq(d1, fst(d2)) ]->
  [ !TLSKey($A, $CA, d2, ~skUser) ]

rule TLSKeyLeak:
  [ !TLSKey($A, $CA, d, ~skUser) ]
  --[ CompromisedTLSKey(~skUser) ]->
  [ Out(~skUser) ]

rule CertificateRequest:
  let body = <'cert', $CA, d, pk(~skTLS)>
      certificate = <body, sign(body, ~skCA)>
  in
  [ !DomainOwner($A, d), !TLSKey($A, $CA, d, ~skTLS), !CA($CA, ~skCA) ]
  --[ OnlyOnce(<'certificate', d>) ]->
  [  Out(certificate) ]

// TLS
functions: tlsClientMsg/4, tlsServerMsg/4, tlsClientReceive/2,
  tlsServerReceive/2
equations:
  tlsClientReceive(tlsServerMsg(~sess, domain, ~sk, m), ~sess) = m
, tlsServerReceive(tlsClientMsg(~sess, domain, pk(~sk), m), ~sk) = m
, tlsServerReceive(tlsClientMsg(~sess, domain, pk(~sk), m), ~sk) = ~sess

// ADEM Root Keys
rule Ltk:
  [ Fr(~rootKey) ]
  -->
  [ !Ltk($A, ~rootKey), Out(pk(~rootKey)) ]

rule AssetKey:
  [ Fr(~assetKey) ]
  -->
  [ !LtkAsset($A, ~assetKey), Out(pk(~assetKey)) ]

rule Reveal:
  [ !Ltk($A, ~ltk) ]
  --[ CompromisedADEMParty($A, pk(~ltk))
    , CompromisedParty($A) ]->
  [ Out(~ltk) ]

rule RevealAsset:
  [ !LtkAsset($A, ~ltk) ]
  --[ CompromisedAssetKey($A, pk(~ltk)) ]->
  [ Out(~ltk) ]

functions: sha256/1
rule RootSetupDomains:
  let rootD = <$OI, sha256(pk(~rootKey))>
  in
  [ !Ltk($Party, ~rootKey) ]
  --[ OnlyOnce(<'root', $Party>)
    , OI($Party, $OI) ]->
  [ DomainRegister($Party, $OI), DomainRegister($Party, rootD)
  , RootDomains($Party, ~rootKey, $OI, rootD) ]

rule RootSetupCertificates:
  let bodyOiCert = <'cert', $CA, oi, pk(tlsSk)>
      bodyRootCert = <'cert', $CA, rootD, pk(tlsSk)>
  in
  [ !CA($CA, skCA), RootDomains($P, ~rootKey, oi, rootD)
  , !TLSKey($P, $CA, oi, tlsSk), !TLSKey($P, $CA, rootD, tlsSk)
  , !MHTLeaf($Log, <bodyOiCert, sigOiCert>), !MHTLeaf($Log, <bodyRootCert, sigRootCert>)
  , In(<bodyOiCert, sigOiCert>)
  , In(<bodyRootCert, sigRootCert>) ]
  --[ IsRootPK($P, oi, pk(~rootKey))
    , Eq(verify(sigOiCert, bodyOiCert, pk(skCA)), true)
    , Eq(verify(sigRootCert, bodyRootCert, pk(skCA)), true) ]->
  [ !RootSetup($P, ~rootKey, oi, rootD) ]

rule RootKeyLearn:
  let certOi = <'cert', $CA, oi, pk(tlsSk)>
      certRootD = <'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>
  in
  [ !CA($CA, skCA), !Log($Log)
  , !MHTLeaf($Log, <certOi, certOiSig>), !MHTLeaf($Log, <certRootD, certRootDSig>) ]
  --[ Eq(verify(certOiSig, certOi, pk(skCA)), true)
    , Eq(verify(certRootDSig, certRootD, pk(skCA)), true)
    , VerifiedRootKey(oi, rootKey)
    , RootCertVerified(<certRootD, certRootDSig>)
    , LogInclusionVerified($Log, certOi)
    , LogInclusionVerified($Log, certRootD) ]->
  [ RootKeyVerified(oi, rootKey) ]

lemma CanObtainRootKey:
  exists-trace
  " (Ex oi rootKey #t. VerifiedRootKey(oi, rootKey) @ #t)
  & (not Ex p #x. CompromisedParty(p) @ #x)
  & (not Ex sk #x. CompromisedTLSKey(sk) @ #x)
  & (not Ex ca m #x. SigningOracleCA(ca, m) @ #x)"

// ADEM endorsements and emblem distribution
rule Asset:
  [ !LtkAsset($E, assetKey), !RootSetup($P, rootKey, oi, rootD) ]
  --[ IsAsset($P, $E, pk(assetKey))
    , OnlyOnce(<'asset', $E>) ]->
  [ !AssetOf($P, $E, assetKey) ]

rule EndorseAsset:
  let body = <'end_int', oi, pk(assetKey)>
      endorsement = <pk(rootKey), body, sign(body, rootKey)>
  in
  [ !AssetOf($P, $E, assetKey)
  , !RootSetup($P, rootKey, oi, rootD) ]
  --[ OnlyOnce(<'endorsed', $E>) ]->
  [ Out(endorsement) ]

rule EndorseParty:
  let body = <'end_ext', oiS, oiT, pk(rootKeyT)>
      endorsement = <pk(rootKeyS), body, sign(body, rootKeyS)>
  in
  [ !RootSetup($Endorsed, rootKeyT, oiT, rootDT)
  , !RootSetup($Endorser, rootKeyS, oiS, rootDS) ]
  -->
  [ Out(endorsement) ]

rule SendEmblem:
  let body = <'emblem', $E, oi>
      emblem = <pk(assetKey), body, sign(body, assetKey)>
  in
  [ !AssetOf($P, $E, assetKey), !RootSetup($P, rootKey, oi, rootD) ]
  -->
  [ Out(emblem) ]

rule ReceiveEmblem:
  let emblemBody = <'emblem', $E, oi>
      body = <'end_int', oi, epk>
      certBody = <'cert', $CA, oi, tlsPk>
  in
  [ Fr(~id)
  , In(<epk, emblemBody, emblemSignature>)
  , In(<rootKey, body, signature>)
  , RootKeyVerified(oi, rootKey)
  ]
  --[ VerifiedEndorsed(~id, oi, $E, epk)
    , VerifiedRootEndorsement(~id, oi, rootKey)
    , Eq(verify(emblemSignature, emblemBody, epk), true)
    , Eq(verify(signature, body, rootKey), true) ]->
  [ VerifyAuthorityEndorsements(~id, oi, rootKey, $E) ]

// Non-deterministically choose to terminate
rule VerifyAuthorityEndorsementsTerminate:
  [ VerifyAuthorityEndorsements(~id, oi, rootKey, $E) ]
  -->
  []

rule ReceiveAuthorityEndorsement:
  let endBody = <'end_ext', auth, oi, rootKey>
      certBody = <'cert', $CA, auth, tlsKey>
  in
  [ VerifyAuthorityEndorsements(~id, oi, rootKey, $E)
  , Fr(~sess)
  , In(<authPk, endBody, endSignature>)
  , RootKeyVerified(auth, authPk) ]
  --[ Neq(auth, oi)
    , Eq(verify(endSignature, endBody, authPk), true)
    , VerifiedAuthorityEndorsement(~id, auth, authPk, oi, rootKey) ]->
  [ VerifyAuthorityEndorsements(~id, oi, rootKey, $E) ]

lemma CanReceiveEmblem:
  exists-trace
  " (Ex id oi asset assetKey rootKey p1 p2 p1Pk p2Pk #a #b #c #d.
      VerifiedEndorsed(id, oi, asset, assetKey) @ #a
    & VerifiedRootEndorsement(id, oi, rootKey) @ #b
    & VerifiedAuthorityEndorsement(id, p1, p1Pk, oi, rootKey) @ #c
    & VerifiedAuthorityEndorsement(id, p2, p2Pk, oi, rootKey) @ #d
    & not (p1 = p2))
  & (not Ex p #x. CompromisedParty(p) @ #x)
  & (not Ex d #x. CompromisedTLSKey(d) @ #x)
  & (not Ex ca m #x. SigningOracleCA(ca, m) @ #x)"

lemma VerifiedAuthorityOrigin[reuse,use_induction]:
  "All loop auth authKey oi rootKey #t1. VerifiedAuthorityEndorsement(loop, auth, authKey, oi, rootKey) @ #t1
    ==> ( (Ex #t2. VerifiedRootEndorsement(loop, oi, rootKey) @ #t2 & #t2 < #t1)
        & (All p1 p2 rk1 rk2 #t2 #t3. VerifiedRootEndorsement(loop, p1, rk1) @ #t2
                & VerifiedRootEndorsement(loop, p2, rk2) @ #t3
            ==> oi = p1 & p1 = p2 & #t2 = #t3 & rootKey = rk1 & rk1 = rk2))"

lemma AuthenticEmblem:
  "All id oi asset assetKey rootKey #t1 #t2.
        ( VerifiedEndorsed(id, oi, asset, assetKey) @ #t1
        & VerifiedRootEndorsement(id, oi, rootKey) @ #t2)
    ==> ( (Ex pp #x #y. OI(pp, oi) @ #x & IsAsset(pp, asset, assetKey) @ #y)
        | (Ex p #x #y. OI(p, oi) @ #x & CompromisedADEMParty(p, rootKey) @ #y)
        | (Ex otherA #x. CompromisedAssetKey(otherA, assetKey) @ #x)
        | (not Ex authOi authPk endorsedKey #t3. VerifiedAuthorityEndorsement(id, authPk, authOi, oi, endorsedKey) @ #t3)
        | (All authOI authPk endorsedKey #x. VerifiedAuthorityEndorsement(id, authOI, authPk, oi, endorsedKey) @ #x
            ==> ( (Ex p #y #z. OI(p, authOI) @ #y & CompromisedADEMParty(p, authPk) @ #z)
                | (not Ex p #y. IsRootPK(p, authOI, authPk) @ #y))))"

rule MonitorLogs:
  let cert = <'cert', $SigningCA, d, pkTLS>
  in
  [ !MHTLeaf($Log, <cert, sig>), !TLSKey($P, $CA, d, skTLS) ]
  --[ Neq(pk(skTLS), pkTLS)
    , Dispute($P, $Log, $SigningCA, d, pkTLS) ]->
  []

lemma CanDisupte:
  exists-trace
  "Ex p log ca d pk #t. Dispute(p, log, ca, d, pk) @ #t"

lemma CAAccountability:
  "All p log ca d pk skCA #x #y #z.
        ( Dispute(p, log, ca, d, pk) @ #x
        & CASk(ca, skCA) @ #y
        & LogInclusion(log, <<'cert', ca, d, pk>, sign(<'cert', ca, d, pk>, skCA)>) @ #z)
    ==> (Ex #a. CompromisedParty(ca) @ #a)"

lemma AuthorityAccountability:
  "All p pAuth oi rk_true rk_false id oiAuth rkAuth #t1 #t2 #t3.
        ( IsRootPK(p, oi, rk_true) @ #t1
        & IsRootPK(pAuth, oiAuth, rkAuth) @ #t2
        & VerifiedAuthorityEndorsement(id, oiAuth, rkAuth, oi, rk_false) @ #t3
        & not (rk_true = rk_false))
    ==> (Ex #a. CompromisedParty(pAuth) @ #a)"

lemma PPAccountability:
  "All p oi rk e1 assetKey id #t1 #t2 #t3.
        ( IsRootPK(p, oi, rk) @ #t1
        & VerifiedRootEndorsement(id, oi, rk) @ #t2
        & VerifiedEndorsed(id, oi, e1, assetKey) @ #t3
        // NOTE: It is correct to not require that e1 and e2 are the same
        // because in our threat model, the attacker could use they assetKey
        // for one asset anyways, but not in this model.
        & (not Ex e2 #x. IsAsset(p, e2, assetKey) @ #x))
    ==> (Ex #a. CompromisedParty(p) @ #a)"

predicates:
      ExBindingCert(oi, rootPk)
  <=> Ex ca log pk sig1 sig2 #t1 #t2.
          LogInclusion(log, <<'cert', ca, oi, pk>, sig1>) @ #t1
        & LogInclusion(log, <<'cert', ca, <oi, sha256(rootPk)>, pk>, sig2>) @ #t2,
      ExBindingCertCA(ca, oi, rootPk)
  <=> Ex ca log pk sig1 sig2 #t1 #t2.
          LogInclusion(log, <<'cert', ca, oi, pk>, sig1>) @ #t1
        & LogInclusion(log, <<'cert', ca, <oi, sha256(rootPk)>, pk>, sig2>) @ #t2

predicates:
      ExFraudLogged(oi, rootPk, ca, skCA)
  <=> Ex log pk #t1 #t2.
          LogInclusion(log, <<'cert', ca, oi, pk>, sign(<'cert', ca, oi, pk>, skCA)>) @ #t1
        & LogInclusion(log, <<'cert', ca, <oi, sha256(rootPk)>, pk>, sign(<'cert', ca, <oi, sha256(rootPk)>, pk>, skCA)>) @ #t2

lemma AccountabilityCompleteness:
  "All id oi asset assetKey rootKey authPk authOi endorsedKey #t1 #t2 #t3.
        ( VerifiedEndorsed(id, oi, asset, assetKey) @ #t1
        & VerifiedRootEndorsement(id, oi, rootKey) @ #t2
        & VerifiedAuthorityEndorsement(id, authPk, authOi, oi, endorsedKey) @ #t3
        & (not Ex pp #x #y. OI(pp, oi) @ #x & IsAsset(pp, asset, assetKey) @ #y)
        & (not Ex otherA #x. CompromisedAssetKey(otherA, assetKey) @ #x))
    ==> ( (Ex p #x #y. OI(p, oi) @ #x & CompromisedADEMParty(p, rootKey) @ #y & ExBindingCert(oi, rootKey))
        | (Ex p #x #y. OI(p, authOi) @ #x & CompromisedADEMParty(p, authPk) @ #y & ExBindingCert(authOi, authPk))
        | (Ex ca #x. CompromisedCA(ca) @ #x & ExBindingCertCA(ca, oi, rootKey))
        | (Ex ca #x. CompromisedCA(ca) @ #x & ExBindingCertCA(ca, authOi, authPk)))"

restriction Eq:
    "All a b #i. Eq(a, b) @ #i ==> a = b"

restriction Neq:
  "All a b #i. Neq(a, b) @ #i ==> not (a = b)"

restriction OnlyOnce:
  "All #i #j a. OnlyOnce(a) @ #i & OnlyOnce(a) @ #j ==> #i = #j"

end
