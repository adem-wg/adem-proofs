theory ADEM begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, pk/1, sha256/1, sign/2, snd/1, tlsClientMsg/4,
           tlsClientReceive/2, tlsServerMsg/4, tlsServerReceive/2, true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    tlsClientReceive(tlsServerMsg(~sess, domain, ~sk, m), ~sess) = m,
    tlsServerReceive(tlsClientMsg(~sess, domain, pk(~sk), m), ~sk) = ~sess,
    tlsServerReceive(tlsClientMsg(~sess, domain, pk(~sk), m), ~sk) = m,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true

heuristic: o "./oracle.py"

rule (modulo E) DomainRegister:
   [ DomainRegister( $A, d ) ]
  --[ OnlyOnce( <'domain_register', d> ), NoTuple( d ) ]->
   [ !DomainOwner( $A, d ), Out( d ) ]

  /* has exactly the trivial AC variant */

restriction NoTuple:
  "∀ m #t. (NoTuple( m ) @ #t) ⇒ (¬(∃ l r. m = <l, r>))"
  // safety formula

rule (modulo E) SubdomainRegister:
   [ DomainRegister( $A, <d, sub> ), !DomainOwner( $A, d ) ]
  --[ OnlyOnce( <'domain_register', d, sub> ) ]->
   [ !DomainOwner( $A, <d, sub> ), Out( <d, sub> ) ]

  // loop breaker: [1]
  /* has exactly the trivial AC variant */

rule (modulo E) DomainCompromise:
   [ !DomainOwner( $A, d ) ]
  --[ CompromisedDomain( d ) ]->
   [ !DomainCompromised( d ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) LogRegister:
   [ Fr( ~skLog ) ]
  --[ LogSk( $Log, ~skLog ) ]->
   [ !Log( $Log, ~skLog ), Out( pk(~skLog) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) LogCompromise:
   [ !Log( $Log, ~skLog ) ]
  --[ CompromisedParty( $Log ) ]->
   [ !LogCompromised( $Log ), Out( ~skLog ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Submit:
   [ !CA( $CA, skCA ), !Log( $Log, skLog ), In( <certBody, certSig> ) ]
  --[
  Eq( verify(certSig, certBody, pk(skCA)), true ),
  Eq( fst(snd(certBody)), $CA ), LogInclusion( $Log, certBody ),
  SignatureStore( $Log, certSig )
  ]->
   [
   Out( <<'sct', certBody>, sign(<'sct', certBody>, skLog)> ),
   !StoredSig( $Log, certSig ), !MHTLeaf( $Log, certBody )
   ]

  /*
  rule (modulo AC) Submit:
     [ !CA( $CA, skCA ), !Log( $Log, skLog ), In( <certBody, certSig> ) ]
    --[
    Eq( z, true ), Eq( z.1, $CA ), LogInclusion( $Log, certBody ),
    SignatureStore( $Log, certSig )
    ]->
     [
     Out( <<'sct', certBody>, sign(<'sct', certBody>, skLog)> ),
     !StoredSig( $Log, certSig ), !MHTLeaf( $Log, certBody )
     ]
    variants (modulo AC)
    1. certBody
             = certBody.11
       certSig
             = certSig.12
       skCA  = skCA.13
       z     = verify(certSig.12, certBody.11, pk(skCA.13))
       z.1   = fst(snd(certBody.11))
    
    2. certBody
             = certBody.12
       certSig
             = sign(certBody.12, skCA.14)
       skCA  = skCA.14
       z     = true
       z.1   = fst(snd(certBody.12))
    
    3. certBody
             = <x.18, x.19>
       certSig
             = sign(<x.18, x.19>, skCA.13)
       skCA  = skCA.13
       z     = true
       z.1   = fst(x.19)
    
    4. certBody
             = <x.19, x.20>
       certSig
             = certSig.13
       skCA  = skCA.14
       z     = verify(certSig.13, <x.19, x.20>, pk(skCA.14))
       z.1   = fst(x.20)
    
    5. certBody
             = <x.19, z.18, x.21>
       certSig
             = sign(<x.19, z.18, x.21>, skCA.14)
       skCA  = skCA.14
       z     = true
       z.1   = z.18
    
    6. certBody
             = <x.20, z.19, x.22>
       certSig
             = certSig.14
       skCA  = skCA.15
       z     = verify(certSig.14, <x.20, z.19, x.22>, pk(skCA.15))
       z.1   = z.19
  */

rule (modulo E) AdversarialAppend:
   [ !LogCompromised( $Log ), In( msg ) ]
  --[ LogInclusion( $Log, msg ) ]->
   [ !MHTLeaf( $Log, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) AdversarialStoreSig:
   [ !LogCompromised( $Log ), In( msg ) ]
  --[ SignatureStore( $Log, msg ) ]->
   [ !StoredSig( $Log, msg ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CA:
   [ Fr( ~skCA ) ]
  --[ CASk( $CA, ~skCA ), OnlyOnce( <'CA', $CA> ) ]->
   [ !CA( $CA, ~skCA ), Out( pk(~skCA) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) FraudulentCertificate:
   [ !CA( $CA, ~skCA ), In( m ) ]
  --[ SigningOracleCA( $CA, m ), CompromisedParty( $CA ) ]->
   [ Out( <m, sign(m, ~skCA)> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSKeyRegister:
   [ !DomainOwner( $A, d ), !CA( $CA, skCA ), Fr( ~skUser ) ]
  --[ OnlyOnce( <'tls_key', d> ) ]->
   [ !TLSKey( $A, $CA, d, ~skUser ), Out( pk(~skUser) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TLSKeyShare:
   [ !TLSKey( $A, $CA, d1, ~skUser ), !DomainOwner( $A, d2 ) ]
  --[ OnlyOnce( <'tls_key', d2> ), Eq( d1, fst(d2) ) ]->
   [ !TLSKey( $A, $CA, d2, ~skUser ) ]

  // loop breaker: [0]
  /*
  rule (modulo AC) TLSKeyShare:
     [ !TLSKey( $A, $CA, d1, ~skUser ), !DomainOwner( $A, d2 ) ]
    --[ OnlyOnce( <'tls_key', d2> ), Eq( d1, z ) ]->
     [ !TLSKey( $A, $CA, d2, ~skUser ) ]
    variants (modulo AC)
    1. d2    = d2.9
       z     = fst(d2.9)
    
    2. d2    = <z.10, x.12>
       z     = z.10
    // loop breaker: [0]
  */

rule (modulo E) TLSKeyLeak:
   [ !TLSKey( $A, $CA, d, ~skUser ) ]
  --[ CompromisedTLSKey( ~skUser ) ]->
   [ Out( ~skUser ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CertificateRequest:
   [ !DomainOwner( $A, d ), !TLSKey( $A, $CA, d, ~skTLS ), !CA( $CA, ~skCA )
   ]
  --[ OnlyOnce( <'certificate', d> ) ]->
   [
   Out( <<'cert', $CA, d, pk(~skTLS)>, 
         sign(<'cert', $CA, d, pk(~skTLS)>, ~skCA)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Ltk:
   [ Fr( ~ltk ) ] --> [ !Ltk( $A, ~ltk ), Out( pk(~ltk) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal:
   [ !Ltk( $A, ltk ) ]
  --[ CompromisedADEMKey( $A, ltk ), CompromisedParty( $A ) ]->
   [ Out( ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) RootSetupDomains:
   [ !Ltk( $Party, ~ltk ) ]
  --[ OnlyOnce( <'root', $Party> ), OI( $Party, $OI ) ]->
   [
   DomainRegister( $Party, $OI ),
   DomainRegister( $Party, <$OI, sha256(pk(~ltk))> ),
   RootDomains( $Party, ~ltk, $OI, <$OI, sha256(pk(~ltk))> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) RootSetupCertificates:
   [
   !CA( $CA, skCA ), RootDomains( $P, ~rootKey, oi, rootD ),
   !TLSKey( $P, $CA, oi, tlsSk ), !TLSKey( $P, $CA, rootD, tlsSk ),
   In( <<'cert', $CA, oi, pk(tlsSk)>, sigOiCert> ),
   In( <<'cert', $CA, rootD, pk(tlsSk)>, sigRootCert> )
   ]
  --[
  IsRootPK( $P, oi, pk(~rootKey) ),
  Eq( verify(sigOiCert, <'cert', $CA, oi, pk(tlsSk)>, pk(skCA)), true ),
  Eq( verify(sigRootCert, <'cert', $CA, rootD, pk(tlsSk)>, pk(skCA)), true
  )
  ]->
   [ !RootSetup( $P, ~rootKey, oi, rootD ) ]

  /*
  rule (modulo AC) RootSetupCertificates:
     [
     !CA( $CA, skCA ), RootDomains( $P, ~rootKey, oi, rootD ),
     !TLSKey( $P, $CA, oi, tlsSk ), !TLSKey( $P, $CA, rootD, tlsSk ),
     In( <<'cert', $CA, oi, pk(tlsSk)>, sigOiCert> ),
     In( <<'cert', $CA, rootD, pk(tlsSk)>, sigRootCert> )
     ]
    --[ IsRootPK( $P, oi, pk(~rootKey) ), Eq( z, true ), Eq( z.1, true ) ]->
     [ !RootSetup( $P, ~rootKey, oi, rootD ) ]
    variants (modulo AC)
    1. $CA   = $CA.14
       oi    = oi.17
       rootD = rootD.18
       sigOiCert
             = sigOiCert.19
       sigRootCert
             = sigRootCert.20
       skCA  = skCA.21
       tlsSk = tlsSk.22
       z     = verify(sigOiCert.19, <'cert', $CA.14, oi.17, pk(tlsSk.22)>,
                      pk(skCA.21))
       z.1   = verify(sigRootCert.20, <'cert', $CA.14, rootD.18, pk(tlsSk.22)>,
                      pk(skCA.21))
    
    2. $CA   = $CA.20
       oi    = oi.23
       rootD = rootD.24
       sigOiCert
             = sign(<'cert', $CA.20, oi.23, pk(tlsSk.28)>, skCA.27)
       sigRootCert
             = sign(<'cert', $CA.20, rootD.24, pk(tlsSk.28)>, skCA.27)
       skCA  = skCA.27
       tlsSk = tlsSk.28
       z     = true
       z.1   = true
    
    3. $CA   = $CA.21
       oi    = oi.24
       rootD = rootD.25
       sigOiCert
             = sign(<'cert', $CA.21, oi.24, pk(tlsSk.29)>, skCA.28)
       sigRootCert
             = sigRootCert.27
       skCA  = skCA.28
       tlsSk = tlsSk.29
       z     = true
       z.1   = verify(sigRootCert.27, <'cert', $CA.21, rootD.25, pk(tlsSk.29)>,
                      pk(skCA.28))
    
    4. $CA   = $CA.22
       oi    = oi.25
       rootD = rootD.26
       sigOiCert
             = sigOiCert.27
       sigRootCert
             = sign(<'cert', $CA.22, rootD.26, pk(tlsSk.30)>, skCA.29)
       skCA  = skCA.29
       tlsSk = tlsSk.30
       z     = verify(sigOiCert.27, <'cert', $CA.22, oi.25, pk(tlsSk.30)>,
                      pk(skCA.29))
       z.1   = true
  */

rule (modulo E) RootKeyQuery:
   [ RootKeyQuery( ~sess, oi, tlsPk ) ]
  -->
   [
   Out( tlsClientMsg(~sess, oi, tlsPk, 'root_key_q') ),
   St_RootKeyQueried( ~sess, oi, tlsPk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) RootKeyTell:
   [
   !RootSetup( $P, ~rootKey, oi, rootD ), !CA( $CA, skCA ),
   !TLSKey( $P, $CA, oi, skTLS ),
   In( <<'cert', $CA, oi, pk(skTLS)>, sigOiCert> ),
   In( tlsClientMsg(~sess, oi, pk(skTLS), 'root_key_q') )
   ]
  --[ Eq( verify(sigOiCert, <'cert', $CA, oi, pk(skTLS)>, pk(skCA)), true )
  ]->
   [ Out( tlsServerMsg(~sess, oi, skTLS, <'root_key', pk(~rootKey)>) ) ]

  /*
  rule (modulo AC) RootKeyTell:
     [
     !RootSetup( $P, ~rootKey, oi, rootD ), !CA( $CA, skCA ),
     !TLSKey( $P, $CA, oi, skTLS ),
     In( <<'cert', $CA, oi, pk(skTLS)>, sigOiCert> ),
     In( tlsClientMsg(~sess, oi, pk(skTLS), 'root_key_q') )
     ]
    --[ Eq( z, true ) ]->
     [ Out( tlsServerMsg(~sess, oi, skTLS, <'root_key', pk(~rootKey)>) ) ]
    variants (modulo AC)
    1. $CA   = $CA.23
       oi    = oi.27
       sigOiCert
             = sigOiCert.29
       skCA  = skCA.30
       skTLS = skTLS.31
       z     = verify(sigOiCert.29, <'cert', $CA.23, oi.27, pk(skTLS.31)>,
                      pk(skCA.30))
    
    2. $CA   = $CA.23
       oi    = oi.27
       sigOiCert
             = sign(<'cert', $CA.23, oi.27, pk(skTLS.31)>, skCA.30)
       skCA  = skCA.30
       skTLS = skTLS.31
       z     = true
  */

rule (modulo E) RootKeyLearn:
   [
   !CA( $CA, skCA ), !Log( $Log, skLog ),
   St_RootKeyQueried( ~sess, oi, pk(tlsSk) ),
   !MHTLeaf( $Log, <'cert', $CA, oi, pk(tlsSk)> ),
   !MHTLeaf( $Log, <'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)> ),
   !StoredSig( $Log, certOiSig ), !StoredSig( $Log, certRootDSig ),
   In( tlsServerMsg(~sess, oi, tlsSk, <'root_key', rootKey>) ),
   In( <<'sct', 'cert', $CA, oi, pk(tlsSk)>, sctOiSig> ),
   In( <<'sct', 'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>, sctRootDSig>
   )
   ]
  --[
  Eq( verify(sctOiSig, <'sct', 'cert', $CA, oi, pk(tlsSk)>, pk(skLog)),
      true
  ),
  Eq( verify(sctRootDSig,
             <'sct', 'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>, pk(skLog)),
      true
  ),
  Eq( verify(certOiSig, <'cert', $CA, oi, pk(tlsSk)>, pk(skCA)), true ),
  Eq( verify(certRootDSig, <'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>,
             pk(skCA)),
      true
  ),
  ObtainedRootKey( oi, rootKey ),
  RootCertVerified( <<'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>, 
                     certRootDSig>
  ),
  RootSCTVerified( <
                    <'sct', 'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>, sctRootDSig>
  )
  ]->
   [ RootKeyResponse( ~sess, oi, rootKey ) ]

  /*
  rule (modulo AC) RootKeyLearn:
     [
     !CA( $CA, skCA ), !Log( $Log, skLog ),
     St_RootKeyQueried( ~sess, oi, pk(tlsSk) ),
     !MHTLeaf( $Log, <'cert', $CA, oi, pk(tlsSk)> ),
     !MHTLeaf( $Log, <'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)> ),
     !StoredSig( $Log, certOiSig ), !StoredSig( $Log, certRootDSig ),
     In( tlsServerMsg(~sess, oi, tlsSk, <'root_key', rootKey>) ),
     In( <<'sct', 'cert', $CA, oi, pk(tlsSk)>, sctOiSig> ),
     In( <<'sct', 'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>, sctRootDSig>
     )
     ]
    --[
    Eq( z, true ), Eq( z.1, true ), Eq( z.2, true ), Eq( z.3, true ),
    ObtainedRootKey( oi, rootKey ),
    RootCertVerified( <<'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>, 
                       certRootDSig>
    ),
    RootSCTVerified( <
                      <'sct', 'cert', $CA, <oi, sha256(rootKey)>, pk(tlsSk)>, sctRootDSig>
    )
    ]->
     [ RootKeyResponse( ~sess, oi, rootKey ) ]
    variants (modulo AC)
     1. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
     2. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = true
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
     3. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
     4. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = true
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
     5. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = true
    
     6. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = true
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = true
    
     7. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = true
    
     8. $CA   = $CA.32
        certOiSig
              = certOiSig.35
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = true
        z.2   = verify(certOiSig.35, <'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skCA.41))
        z.3   = true
    
     9. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = true
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
    10. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = true
        z.2   = true
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
    11. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = true
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
    12. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = certRootDSig.36
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = true
        z.2   = true
        z.3   = verify(certRootDSig.36,
                       <'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>, pk(skCA.41))
    
    13. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = true
        z.3   = true
    
    14. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sctOiSig.39
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = verify(sctOiSig.39, <'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.1   = true
        z.2   = true
        z.3   = true
    
    15. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sctRootDSig.40
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = verify(sctRootDSig.40,
                       <'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                       pk(skLog.42))
        z.2   = true
        z.3   = true
    
    16. $CA   = $CA.32
        certOiSig
              = sign(<'cert', $CA.32, oi.37, pk(tlsSk.43)>, skCA.41)
        certRootDSig
              = sign(<'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)>,
                     skCA.41)
        oi    = oi.37
        rootKey
              = rootKey.38
        sctOiSig
              = sign(<'sct', 'cert', $CA.32, oi.37, pk(tlsSk.43)>, skLog.42)
        sctRootDSig
              = sign(<'sct', 'cert', $CA.32, <oi.37, sha256(rootKey.38)>, pk(tlsSk.43)
                     >,
                     skLog.42)
        skCA  = skCA.41
        skLog = skLog.42
        tlsSk = tlsSk.43
        z     = true
        z.1   = true
        z.2   = true
        z.3   = true
  */

lemma CanObtainRootKey:
  exists-trace
  "(((∃ oi rootKey #t. ObtainedRootKey( oi, rootKey ) @ #t) ∧
     (¬(∃ p #x. CompromisedParty( p ) @ #x))) ∧
    (¬(∃ sk #x. CompromisedTLSKey( sk ) @ #x))) ∧
   (¬(∃ ca m #x. SigningOracleCA( ca, m ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"(∃ oi rootKey #t. (ObtainedRootKey( oi, rootKey ) @ #t)) ∧
 (∀ p #x. (CompromisedParty( p ) @ #x) ⇒ ⊥) ∧
 (∀ sk #x. (CompromisedTLSKey( sk ) @ #x) ⇒ ⊥) ∧
 (∀ ca m #x. (SigningOracleCA( ca, m ) @ #x) ⇒ ⊥)"
*/
by sorry

rule (modulo E) Asset:
   [ !Ltk( $E, assetKey ), !RootSetup( $P, rootKey, oi, rootD ) ]
  --[ IsAsset( $P, $E, pk(assetKey) ), OnlyOnce( <'asset', $E> ) ]->
   [ !AssetOf( $P, $E, assetKey ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) EndorseAsset:
   [ !AssetOf( $P, $E, assetKey ), !RootSetup( $P, rootKey, oi, rootD ) ]
  --[ OnlyOnce( <'endorsed', $E> ) ]->
   [
   Out( <pk(rootKey), <'end_int', oi, pk(assetKey)>, 
         sign(<'end_int', oi, pk(assetKey)>, rootKey)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) EndorseParty:
   [
   !RootSetup( $Endorsed, rootKeyT, oiT, rootDT ),
   !RootSetup( $Endorser, rootKeyS, oiS, rootDS )
   ]
  -->
   [
   Out( <pk(rootKeyS), <'end_ext', oiS, oiT, pk(rootKeyT)>, 
         sign(<'end_ext', oiS, oiT, pk(rootKeyT)>, rootKeyS)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SendEmblem:
   [ !AssetOf( $P, $E, assetKey ), !RootSetup( $P, rootKey, oi, rootD ) ]
  -->
   [
   Out( <pk(assetKey), <'emblem', $E, oi>, 
         sign(<'emblem', $E, oi>, assetKey)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) ReceiveEmblem:
   [
   !CA( $CA, ~skCA ), Fr( ~id ), Fr( ~sess ),
   In( <<'cert', $CA, oi, tlsPk>, certSignature> ),
   In( <epk, <'emblem', $E, oi>, emblemSignature> )
   ]
  --[
  VerifiedEndorsed( ~id, oi, $E, epk ),
  Eq( verify(emblemSignature, <'emblem', $E, oi>, epk), true ),
  Eq( verify(certSignature, <'cert', $CA, oi, tlsPk>, pk(~skCA)), true )
  ]->
   [
   RootKeyQuery( ~sess, oi, tlsPk ),
   VerifyEndorsements( ~id, ~sess, oi, $E, epk )
   ]

  /*
  rule (modulo AC) ReceiveEmblem:
     [
     !CA( $CA, ~skCA ), Fr( ~id ), Fr( ~sess ),
     In( <<'cert', $CA, oi, tlsPk>, certSignature> ),
     In( <epk, <'emblem', $E, oi>, emblemSignature> )
     ]
    --[ VerifiedEndorsed( ~id, oi, $E, epk ), Eq( z, true ), Eq( z.1, true )
    ]->
     [
     RootKeyQuery( ~sess, oi, tlsPk ),
     VerifyEndorsements( ~id, ~sess, oi, $E, epk )
     ]
    variants (modulo AC)
    1. $CA   = $CA.25
       $E    = $E.26
       ~skCA = ~skCA.29
       certSignature
             = certSignature.30
       emblemSignature
             = emblemSignature.31
       epk   = epk.32
       oi    = oi.33
       tlsPk = tlsPk.34
       z     = verify(emblemSignature.31, <'emblem', $E.26, oi.33>, epk.32)
       z.1   = verify(certSignature.30, <'cert', $CA.25, oi.33, tlsPk.34>,
                      pk(~skCA.29))
    
    2. $CA   = $CA.25
       $E    = $E.26
       ~skCA = ~skCA.29
       certSignature
             = sign(<'cert', $CA.25, oi.33, tlsPk.34>, ~skCA.29)
       emblemSignature
             = emblemSignature.31
       epk   = epk.32
       oi    = oi.33
       tlsPk = tlsPk.34
       z     = verify(emblemSignature.31, <'emblem', $E.26, oi.33>, epk.32)
       z.1   = true
    
    3. $CA   = $CA.36
       $E    = $E.37
       ~skCA = ~skCA.40
       certSignature
             = certSignature.41
       emblemSignature
             = sign(<'emblem', $E.37, oi.44>, x.70)
       epk   = pk(x.70)
       oi    = oi.44
       tlsPk = tlsPk.45
       z     = true
       z.1   = verify(certSignature.41, <'cert', $CA.36, oi.44, tlsPk.45>,
                      pk(~skCA.40))
    
    4. $CA   = $CA.37
       $E    = $E.38
       ~skCA = ~skCA.41
       certSignature
             = sign(<'cert', $CA.37, oi.45, tlsPk.46>, ~skCA.41)
       emblemSignature
             = sign(<'emblem', $E.38, oi.45>, x.72)
       epk   = pk(x.72)
       oi    = oi.45
       tlsPk = tlsPk.46
       z     = true
       z.1   = true
  */

rule (modulo E) ReceiveInternalEndorsement:
   [
   VerifyEndorsements( ~id, ~sess, oi, $E, epk ),
   RootKeyResponse( ~sess, oi, rootKey ),
   In( <rootKey, <'end_int', oi, epk>, signature> )
   ]
  --[
  VerifiedRootEndorsement( ~id, oi, rootKey ), UsedRootKey( oi, rootKey ),
  Eq( verify(signature, <'end_int', oi, epk>, rootKey), true )
  ]->
   [ VerifyAuthorityEndorsements( ~id, oi, rootKey, $E ) ]

  // loop breaker: [1]
  /*
  rule (modulo AC) ReceiveInternalEndorsement:
     [
     VerifyEndorsements( ~id, ~sess, oi, $E, epk ),
     RootKeyResponse( ~sess, oi, rootKey ),
     In( <rootKey, <'end_int', oi, epk>, signature> )
     ]
    --[
    VerifiedRootEndorsement( ~id, oi, rootKey ), UsedRootKey( oi, rootKey ),
    Eq( z, true )
    ]->
     [ VerifyAuthorityEndorsements( ~id, oi, rootKey, $E ) ]
    variants (modulo AC)
    1. epk   = epk.11
       oi    = oi.12
       rootKey
             = rootKey.13
       signature
             = signature.14
       z     = verify(signature.14, <'end_int', oi.12, epk.11>, rootKey.13)
    
    2. epk   = epk.13
       oi    = oi.14
       rootKey
             = pk(x.21)
       signature
             = sign(<'end_int', oi.14, epk.13>, x.21)
       z     = true
    // loop breaker: [1]
  */

rule (modulo E) VerifyAuthorityEndorsementsTerminate:
   [ VerifyAuthorityEndorsements( ~id, oi, rootKey, $E ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) ReceiveAuthorityEndorsement:
   [
   VerifyAuthorityEndorsements( ~id, oi, rootKey, $E ), !CA( $CA, skCA ),
   Fr( ~sess ), In( <<'cert', $CA, auth, tlsKey>, certSignature> ),
   In( <authPk, <'end_ext', auth, oi, rootKey>, endSignature> )
   ]
  --[
  Neq( auth, oi ),
  Eq( verify(endSignature, <'end_ext', auth, oi, rootKey>, authPk), true ),
  Eq( verify(certSignature, <'cert', $CA, auth, tlsKey>, pk(skCA)), true )
  ]->
   [
   RootKeyQuery( ~sess, auth, tlsKey ),
   VerifyAuthoritySetup( ~id, ~sess, auth, authPk, oi, rootKey, $E )
   ]

  /*
  rule (modulo AC) ReceiveAuthorityEndorsement:
     [
     VerifyAuthorityEndorsements( ~id, oi, rootKey, $E ), !CA( $CA, skCA ),
     Fr( ~sess ), In( <<'cert', $CA, auth, tlsKey>, certSignature> ),
     In( <authPk, <'end_ext', auth, oi, rootKey>, endSignature> )
     ]
    --[ Neq( auth, oi ), Eq( z, true ), Eq( z.1, true ) ]->
     [
     RootKeyQuery( ~sess, auth, tlsKey ),
     VerifyAuthoritySetup( ~id, ~sess, auth, authPk, oi, rootKey, $E )
     ]
    variants (modulo AC)
    1. $CA   = $CA.29
       auth  = auth.33
       authPk
             = authPk.34
       certSignature
             = certSignature.35
       endSignature
             = endSignature.36
       oi    = oi.37
       rootKey
             = rootKey.38
       skCA  = skCA.39
       tlsKey
             = tlsKey.40
       z     = verify(endSignature.36, <'end_ext', auth.33, oi.37, rootKey.38>,
                      authPk.34)
       z.1   = verify(certSignature.35, <'cert', $CA.29, auth.33, tlsKey.40>,
                      pk(skCA.39))
    
    2. $CA   = $CA.29
       auth  = auth.33
       authPk
             = authPk.34
       certSignature
             = sign(<'cert', $CA.29, auth.33, tlsKey.40>, skCA.39)
       endSignature
             = endSignature.36
       oi    = oi.37
       rootKey
             = rootKey.38
       skCA  = skCA.39
       tlsKey
             = tlsKey.40
       z     = verify(endSignature.36, <'end_ext', auth.33, oi.37, rootKey.38>,
                      authPk.34)
       z.1   = true
    
    3. $CA   = $CA.35
       auth  = auth.39
       authPk
             = pk(x.68)
       certSignature
             = certSignature.41
       endSignature
             = sign(<'end_ext', auth.39, oi.43, rootKey.44>, x.68)
       oi    = oi.43
       rootKey
             = rootKey.44
       skCA  = skCA.45
       tlsKey
             = tlsKey.46
       z     = true
       z.1   = verify(certSignature.41, <'cert', $CA.35, auth.39, tlsKey.46>,
                      pk(skCA.45))
    
    4. $CA   = $CA.39
       auth  = auth.43
       authPk
             = pk(x.76)
       certSignature
             = sign(<'cert', $CA.39, auth.43, tlsKey.50>, skCA.49)
       endSignature
             = sign(<'end_ext', auth.43, oi.47, rootKey.48>, x.76)
       oi    = oi.47
       rootKey
             = rootKey.48
       skCA  = skCA.49
       tlsKey
             = tlsKey.50
       z     = true
       z.1   = true
  */

rule (modulo E) AuthoritySetupVerified:
   [
   VerifyAuthoritySetup( ~id, ~sess, auth, authPk, oi, rootKey, $E ),
   RootKeyResponse( ~sess, auth, authPk )
   ]
  --[
  VerifiedAuthorityEndorsement( ~id, auth, authPk, oi, rootKey ),
  UsedRootKey( auth, authPk )
  ]->
   [ VerifyAuthorityEndorsements( ~id, oi, rootKey, $E ) ]

  // loop breakers: [0,1]
  /* has exactly the trivial AC variant */

lemma CanReceiveEmblem:
  exists-trace
  "(((∃ id oi asset assetKey rootKey p1 p2 p1Pk p2Pk #a #b #c #d.
       ((((VerifiedEndorsed( id, oi, asset, assetKey ) @ #a) ∧
          (VerifiedRootEndorsement( id, oi, rootKey ) @ #b)) ∧
         (VerifiedAuthorityEndorsement( id, p1, p1Pk, oi, rootKey ) @ #c)) ∧
        (VerifiedAuthorityEndorsement( id, p2, p2Pk, oi, rootKey ) @ #d)) ∧
       (¬(p1 = p2))) ∧
     (¬(∃ p #x. CompromisedParty( p ) @ #x))) ∧
    (¬(∃ d #x. CompromisedTLSKey( d ) @ #x))) ∧
   (¬(∃ ca m #x. SigningOracleCA( ca, m ) @ #x))"
/*
guarded formula characterizing all satisfying traces:
"(∃ id oi asset assetKey rootKey p1 p2 p1Pk p2Pk #a #b #c #d.
   (VerifiedEndorsed( id, oi, asset, assetKey ) @ #a) ∧
   (VerifiedRootEndorsement( id, oi, rootKey ) @ #b) ∧
   (VerifiedAuthorityEndorsement( id, p1, p1Pk, oi, rootKey ) @ #c) ∧
   (VerifiedAuthorityEndorsement( id, p2, p2Pk, oi, rootKey ) @ #d)
  ∧
   ¬(p1 = p2)) ∧
 (∀ p #x. (CompromisedParty( p ) @ #x) ⇒ ⊥) ∧
 (∀ d #x. (CompromisedTLSKey( d ) @ #x) ⇒ ⊥) ∧
 (∀ ca m #x. (SigningOracleCA( ca, m ) @ #x) ⇒ ⊥)"
*/
by sorry

lemma VerifiedAuthorityOrigin [reuse, use_induction]:
  all-traces
  "∀ loop auth authKey oi rootKey #t1.
    (VerifiedAuthorityEndorsement( loop, auth, authKey, oi, rootKey
     ) @ #t1) ⇒
    ((∃ #t2.
       (VerifiedRootEndorsement( loop, oi, rootKey ) @ #t2) ∧ (#t2 < #t1)) ∧
     (∀ p1 p2 rk1 rk2 #t2 #t3.
       ((VerifiedRootEndorsement( loop, p1, rk1 ) @ #t2) ∧
        (VerifiedRootEndorsement( loop, p2, rk2 ) @ #t3)) ⇒
       (((((oi = p1) ∧ (p1 = p2)) ∧ (#t2 = #t3)) ∧ (rootKey = rk1)) ∧
        (rk1 = rk2))))"
/*
guarded formula characterizing all counter-examples:
"∃ loop auth authKey oi rootKey #t1.
  (VerifiedAuthorityEndorsement( loop, auth, authKey, oi, rootKey ) @ #t1)
 ∧
  ((∀ #t2.
     (VerifiedRootEndorsement( loop, oi, rootKey ) @ #t2) ⇒ ¬(#t2 < #t1)) ∨
   (∃ p1 p2 rk1 rk2 #t2 #t3.
     (VerifiedRootEndorsement( loop, p1, rk1 ) @ #t2) ∧
     (VerifiedRootEndorsement( loop, p2, rk2 ) @ #t3)
    ∧
     ((¬(oi = p1)) ∨
      (¬(p1 = p2)) ∨
      (¬(#t2 = #t3)) ∨
      (¬(rootKey = rk1)) ∨
      (¬(rk1 = rk2)))))"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ #t2.
           (VerifiedRootEndorsement( ~id, oi, rootKey ) @ #t2) ⇒ ¬(#t2 < #t1))  ∥
         (∃ p1 p2 rk1 rk2 #t2 #t3.
           (VerifiedRootEndorsement( ~id, p1, rk1 ) @ #t2) ∧
           (VerifiedRootEndorsement( ~id, p2, rk2 ) @ #t3)
          ∧
           ((¬(oi = p1)) ∨
            (¬(p1 = p2)) ∨
            (¬(#t2 = #t3)) ∨
            (¬(rootKey = rk1)) ∨
            (¬(rk1 = rk2)))) )
    case case_1
    solve( (last(#t1))  ∥
           ((∃ #t2.
              (VerifiedRootEndorsement( ~id, oi, rootKey ) @ #t2)
             ∧
              (¬(last(#t2))) ∧ (#t2 < #t1)) ∧
            (∀ p1 p2 rk1 rk2 #t2 #t3.
              (VerifiedRootEndorsement( ~id, p1, rk1 ) @ #t2) ∧
              (VerifiedRootEndorsement( ~id, p2, rk2 ) @ #t3)
             ⇒
              ((last(#t3)) ∨
               (last(#t2)) ∨
               ((oi = p1) ∧
                (p1 = p2) ∧
                (#t2 = #t3) ∧
                (rootKey = rk1) ∧
                (rk1 = rk2))))) )
      case case_1
      solve( VerifyAuthoritySetup( ~id, ~sess, auth, authKey, oi, rootKey, $E
             ) ▶₀ #t1 )
        case ReceiveAuthorityEndorsement_case_1
        by contradiction /* from formulas */
      next
        case ReceiveAuthorityEndorsement_case_2
        by contradiction /* from formulas */
      qed
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_2
    solve( VerifyEndorsements( ~id, ~sess.1, p1, $E.1, epk ) ▶₀ #t2 )
      case ReceiveEmblem
      solve( VerifyEndorsements( ~id, ~sess.2, p2, $E.2, epk ) ▶₀ #t3 )
        case ReceiveEmblem
        solve( (last(#t1))  ∥
               ((∃ #t2.
                  (VerifiedRootEndorsement( ~id, oi, rootKey ) @ #t2)
                 ∧
                  (¬(last(#t2))) ∧ (#t2 < #t1)) ∧
                (∀ p1 p2 rk1 rk2 #t2 #t3.
                  (VerifiedRootEndorsement( ~id, p1, rk1 ) @ #t2) ∧
                  (VerifiedRootEndorsement( ~id, p2, rk2 ) @ #t3)
                 ⇒
                  ((last(#t3)) ∨
                   (last(#t2)) ∨
                   ((oi = p1) ∧
                    (p1 = p2) ∧
                    (#t2 = #t3) ∧
                    (rootKey = rk1) ∧
                    (rk1 = rk2))))) )
          case case_1
          solve( VerifyAuthoritySetup( ~id, ~sess, auth, authKey, oi, rootKey, $E
                 ) ▶₀ #t1 )
            case ReceiveAuthorityEndorsement_case_1
            by contradiction /* from formulas */
          next
            case ReceiveAuthorityEndorsement_case_2
            by contradiction /* from formulas */
          qed
        next
          case case_2
          solve( VerifyEndorsements( ~id, ~sess.2, oi, $E.2, epk ) ▶₀ #t2.1 )
            case ReceiveEmblem
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  qed
qed

lemma AuthenticEmblem:
  all-traces
  "∀ id oi asset assetKey rootKey #t1 #t2.
    ((VerifiedEndorsed( id, oi, asset, assetKey ) @ #t1) ∧
     (VerifiedRootEndorsement( id, oi, rootKey ) @ #t2)) ⇒
    (((((∃ pp #x. IsAsset( pp, asset, assetKey ) @ #x) ∨
        (∃ p k #x #y. (OI( p, oi ) @ #x) ∧ (CompromisedADEMKey( p, k ) @ #y))) ∨
       (∃ otherE k #x. CompromisedADEMKey( otherE, k ) @ #x)) ∨
      (¬(∃ authOi authPk endorsedKey #t3.
          VerifiedAuthorityEndorsement( id, authPk, authOi, oi, endorsedKey
          ) @ #t3))) ∨
     (∀ authOI authPk endorsedKey #x.
       (VerifiedAuthorityEndorsement( id, authOI, authPk, oi, endorsedKey
        ) @ #x) ⇒
       ((∃ p k #y #z.
          (OI( p, authOI ) @ #y) ∧ (CompromisedADEMKey( p, k ) @ #z)) ∨
        (¬(∃ p #y. IsRootPK( p, authOI, authPk ) @ #y)))))"
/*
guarded formula characterizing all counter-examples:
"∃ id oi asset assetKey rootKey #t1 #t2.
  (VerifiedEndorsed( id, oi, asset, assetKey ) @ #t1) ∧
  (VerifiedRootEndorsement( id, oi, rootKey ) @ #t2)
 ∧
  (∀ pp #x. (IsAsset( pp, asset, assetKey ) @ #x) ⇒ ⊥) ∧
  (∀ p k #x #y.
    (OI( p, oi ) @ #x) ∧ (CompromisedADEMKey( p, k ) @ #y) ⇒ ⊥) ∧
  (∀ otherE k #x. (CompromisedADEMKey( otherE, k ) @ #x) ⇒ ⊥) ∧
  (∃ authOi authPk endorsedKey #t3.
    (VerifiedAuthorityEndorsement( id, authPk, authOi, oi, endorsedKey
     ) @ #t3)) ∧
  (∃ authOI authPk endorsedKey #x.
    (VerifiedAuthorityEndorsement( id, authOI, authPk, oi, endorsedKey
     ) @ #x)
   ∧
    (∀ p k #y #z.
      (OI( p, authOI ) @ #y) ∧ (CompromisedADEMKey( p, k ) @ #z) ⇒ ⊥) ∧
    (∃ p #y. (IsRootPK( p, authOI, authPk ) @ #y)))"
*/
simplify
solve( RootDomains( $P, ~rootKey, authOI, rootD ) ▶₁ #y )
  case RootSetupDomains
  solve( VerifyEndorsements( ~id, ~sess.1, oi, $E.1, epk ) ▶₀ #t2 )
    case ReceiveEmblem
    solve( !KU( sign(<'emblem', $E, oi>, x) ) @ #vk.23 )
      case FraudulentCertificate
      solve( !KU( sign(<'end_int', oi, pk(~skCA.1)>, x) ) @ #vk.27 )
        case FraudulentCertificate
        solve( VerifyAuthoritySetup( ~id, ~sess.2, $OI, pk(~rootKey), oi,
                                     pk(~skCA.2), $E.2
               ) ▶₀ #x )
          case ReceiveAuthorityEndorsement_case_1
          solve( !KU( sign(<'end_ext', $OI, oi, pk(~skCA.2)>, ~rootKey)
                 ) @ #vk.53 )
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.54 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.1), ~rootKey ) ▶₀ #vr.12 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.1, ~rootKey ) ▶₀ #vr.12 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.1), ~rootKey ) ▶₀ #vr.16 )
              qed
            qed
          qed
        next
          case ReceiveAuthorityEndorsement_case_2
          solve( !KU( sign(<'end_ext', $OI, oi, pk(~skCA.2)>, ~rootKey)
                 ) @ #vk.53 )
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.54 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.1), ~rootKey ) ▶₀ #vr.13 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.1, ~rootKey ) ▶₀ #vr.13 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.1), ~rootKey ) ▶₀ #vr.17 )
              qed
            qed
          qed
        qed
      next
        case c_sign
        solve( VerifyAuthoritySetup( ~id, ~sess.2, $OI, pk(~rootKey), oi, pk(x),
                                     $E.2
               ) ▶₀ #x.1 )
          case ReceiveAuthorityEndorsement_case_1
          solve( !KU( sign(<'end_ext', $OI, oi, pk(x)>, ~rootKey) ) @ #vk.54 )
            case EndorseParty_case_1
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_2
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_3
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_4
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_5
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_6
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_7
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_8
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case EndorseParty_case_9
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.25 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.25 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.29 )
              qed
            qed
          next
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.55 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.9 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.1, ~rootKey ) ▶₀ #vr.9 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.13 )
              qed
            qed
          qed
        next
          case ReceiveAuthorityEndorsement_case_2
          solve( !KU( sign(<'end_ext', $OI, oi, pk(x)>, ~rootKey) ) @ #vk.54 )
            case EndorseParty_case_1
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_2
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_3
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_4
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_5
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_6
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_7
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_8
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case EndorseParty_case_9
            solve( !KU( ~rootKey ) @ #vk.51 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.5, $OI.2, ~rootKey ) ▶₀ #vr.26 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.5, fst($OI.2), ~rootKey ) ▶₀ #vr.30 )
              qed
            qed
          next
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.55 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.10 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.1, ~rootKey ) ▶₀ #vr.10 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.14 )
              qed
            qed
          qed
        qed
      qed
    next
      case SendEmblem_case_1
      by contradiction /* from formulas */
    next
      case SendEmblem_case_2
      by contradiction /* from formulas */
    next
      case SendEmblem_case_3
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( sign(<'end_int', oi, pk(x)>, x.1) ) @ #vk.27 )
        case EndorseAsset_case_1
        solve( !KU( ~ltk ) @ #vk.43 )
          case Reveal
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~ltk ) ▶₀ #vr.17 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.3, $OI.2, ~ltk ) ▶₀ #vr.17 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~ltk ) ▶₀ #vr.21 )
          qed
        qed
      next
        case EndorseAsset_case_2
        solve( !KU( ~ltk ) @ #vk.43 )
          case Reveal
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~ltk ) ▶₀ #vr.17 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.3, $OI.2, ~ltk ) ▶₀ #vr.17 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~ltk ) ▶₀ #vr.21 )
          qed
        qed
      next
        case EndorseAsset_case_3
        solve( !KU( ~ltk ) @ #vk.43 )
          case Reveal
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~ltk ) ▶₀ #vr.17 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.3, $OI.2, ~ltk ) ▶₀ #vr.17 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~ltk ) ▶₀ #vr.21 )
          qed
        qed
      next
        case FraudulentCertificate
        solve( VerifyAuthoritySetup( ~id, ~sess.2, $OI, pk(~rootKey), oi,
                                     pk(~skCA.1), $E.2
               ) ▶₀ #x.1 )
          case ReceiveAuthorityEndorsement_case_1
          solve( !KU( sign(<'end_ext', $OI, oi, pk(~skCA.1)>, ~rootKey)
                 ) @ #vk.54 )
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.55 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.9 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.1, ~rootKey ) ▶₀ #vr.9 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.13 )
              qed
            qed
          qed
        next
          case ReceiveAuthorityEndorsement_case_2
          solve( !KU( sign(<'end_ext', $OI, oi, pk(~skCA.1)>, ~rootKey)
                 ) @ #vk.54 )
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.55 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.10 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.1, ~rootKey ) ▶₀ #vr.10 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.1), ~rootKey ) ▶₀ #vr.14 )
              qed
            qed
          qed
        qed
      next
        case c_sign
        solve( VerifyAuthoritySetup( ~id, ~sess.2, $OI, pk(~rootKey), oi,
                                     pk(x.1), $E.2
               ) ▶₀ #x.2 )
          case ReceiveAuthorityEndorsement_case_1
          solve( !KU( sign(<'end_ext', $OI, oi, pk(x.1)>, ~rootKey) ) @ #vk.55 )
            case EndorseParty_case_1
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_2
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_3
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_4
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_5
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_6
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_7
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_8
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case EndorseParty_case_9
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.22 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.22 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.26 )
              qed
            qed
          next
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.56 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~rootKey ) ▶₀ #vr.6 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.3, $OI.1, ~rootKey ) ▶₀ #vr.6 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~rootKey ) ▶₀ #vr.10 )
              qed
            qed
          qed
        next
          case ReceiveAuthorityEndorsement_case_2
          solve( !KU( sign(<'end_ext', $OI, oi, pk(x.1)>, ~rootKey) ) @ #vk.55 )
            case EndorseParty_case_1
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_2
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_3
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_4
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_5
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_6
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_7
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_8
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case EndorseParty_case_9
            solve( !KU( ~rootKey ) @ #vk.52 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.23 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey ) ▶₀ #vr.23 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey ) ▶₀ #vr.27 )
              qed
            qed
          next
            case c_sign
            solve( !KU( ~rootKey ) @ #vk.56 )
              case Reveal
              by contradiction /* from formulas */
            next
              case TLSKeyLeak_case_1
              by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~rootKey ) ▶₀ #vr.7 )
            next
              case TLSKeyLeak_case_2
              solve( !TLSKey( $A, $CA.3, $OI.1, ~rootKey ) ▶₀ #vr.7 )
                case TLSKeyShare
                by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~rootKey ) ▶₀ #vr.11 )
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

rule (modulo E) MonitorLogs:
   [
   !MHTLeaf( $Log, <'cert', $SigningCA, d, pkTLS> ),
   !TLSKey( $P, $CA, d, skTLS )
   ]
  --[ Neq( pk(skTLS), pkTLS ), Dispute( $P, $Log, $SigningCA, d, pkTLS )
  ]->
   [ ]

  /* has exactly the trivial AC variant */

lemma MonitoringImpliesInclusion [reuse]:
  all-traces
  "∀ p l ca d pk #t.
    (Dispute( p, l, ca, d, pk ) @ #t) ⇒
    (∃ #x. LogInclusion( l, <'cert', ca, d, pk> ) @ #x)"
/*
guarded formula characterizing all counter-examples:
"∃ p l ca d pk #t.
  (Dispute( p, l, ca, d, pk ) @ #t)
 ∧
  ∀ #x. (LogInclusion( l, <'cert', ca, d, pk> ) @ #x) ⇒ ⊥"
*/
simplify
solve( !MHTLeaf( $Log, <'cert', $SigningCA, d, pk> ) ▶₀ #t )
  case AdversarialAppend
  by contradiction /* from formulas */
next
  case Submit
  by contradiction /* from formulas */
qed

lemma CAAccountability:
  all-traces
  "∀ p log ca d pk skCA #x #y #z.
    (((Dispute( p, log, ca, d, pk ) @ #x) ∧ (CASk( ca, skCA ) @ #y)) ∧
     (SignatureStore( log, sign(<'cert', ca, d, pk>, skCA) ) @ #z)) ⇒
    (∃ #a. CompromisedParty( ca ) @ #a)"
/*
guarded formula characterizing all counter-examples:
"∃ p log ca d pk skCA #x #y #z.
  (Dispute( p, log, ca, d, pk ) @ #x) ∧
  (CASk( ca, skCA ) @ #y) ∧
  (SignatureStore( log, sign(<'cert', ca, d, pk>, skCA) ) @ #z)
 ∧
  ∀ #a. (CompromisedParty( ca ) @ #a) ⇒ ⊥"
*/
simplify
solve( SignatureStore( $Log, sign(<'cert', $SigningCA, d, pk>, ~skCA)
       ) @ #z )
  case AdversarialStoreSig
  solve( !KU( sign(<'cert', $SigningCA, d, pk>, ~skCA) ) @ #vk )
    case CertificateRequest_case_1
    solve( !TLSKey( $P, $CA, $OI, skTLS.1 ) ▶₁ #x )
      case TLSKeyRegister
      by contradiction /* from formulas */
    qed
  next
    case CertificateRequest_case_2
    solve( !TLSKey( $P, $CA, $OI, skTLS.1 ) ▶₁ #x )
      case TLSKeyShare
      by contradiction /* from formulas */
    qed
  next
    case CertificateRequest_case_3
    solve( !TLSKey( $P, $CA, <$OI, sha256(pk(~ltk))>, skTLS.1 ) ▶₁ #x )
      case TLSKeyRegister
      by contradiction /* from formulas */
    qed
  next
    case CertificateRequest_case_4
    solve( !TLSKey( $P, $CA, <$OI, sha256(pk(~ltk))>, skTLS.1 ) ▶₁ #x )
      case TLSKeyShare
      by contradiction /* from formulas */
    qed
  next
    case FraudulentCertificate
    by contradiction /* from formulas */
  next
    case c_sign
    solve( !KU( ~skCA ) @ #vk.2 )
      case TLSKeyLeak_case_1
      by solve( !TLSKey( $A, $CA.1, fst($OI), ~skCA ) ▶₀ #vr.1 )
    next
      case TLSKeyLeak_case_2
      solve( !TLSKey( $A, $CA.1, $OI, ~skCA ) ▶₀ #vr.1 )
        case TLSKeyShare
        by solve( !TLSKey( $A, $CA, fst($OI), ~skCA ) ▶₀ #vr.5 )
      qed
    qed
  qed
next
  case Submit
  solve( !KU( sign(<'cert', $CA, d, pk>, ~skCA) ) @ #vk.2 )
    case CertificateRequest_case_1
    solve( !TLSKey( $P, $CA.1, $OI, skTLS.1 ) ▶₁ #x )
      case TLSKeyRegister
      by contradiction /* from formulas */
    qed
  next
    case CertificateRequest_case_2
    solve( !TLSKey( $P, $CA.1, $OI, skTLS.1 ) ▶₁ #x )
      case TLSKeyShare
      by contradiction /* from formulas */
    qed
  next
    case CertificateRequest_case_3
    solve( !TLSKey( $P, $CA.1, <$OI, sha256(pk(~ltk))>, skTLS.1 ) ▶₁ #x )
      case TLSKeyRegister
      by contradiction /* from formulas */
    qed
  next
    case CertificateRequest_case_4
    solve( !TLSKey( $P, $CA.1, <$OI, sha256(pk(~ltk))>, skTLS.1 ) ▶₁ #x )
      case TLSKeyShare
      by contradiction /* from formulas */
    qed
  next
    case FraudulentCertificate
    by contradiction /* from formulas */
  next
    case c_sign
    solve( !KU( ~skCA ) @ #vk.9 )
      case TLSKeyLeak_case_1
      by solve( !TLSKey( $A, $CA.2, fst($OI), ~skCA ) ▶₀ #vr.1 )
    next
      case TLSKeyLeak_case_2
      solve( !TLSKey( $A, $CA.2, $OI, ~skCA ) ▶₀ #vr.1 )
        case TLSKeyShare
        by solve( !TLSKey( $A, $CA.1, fst($OI), ~skCA ) ▶₀ #vr.5 )
      qed
    qed
  qed
qed

lemma LogAccountability:
  all-traces
  "∀ p oi rk_true rk_false ca caSk log logSk certBody tlsPk certSig sctBody
     sctSig #t1 #t3 #t4 #t5 #t6.
    ((((((((((((IsRootPK( p, oi, rk_true ) @ #t1) ∧
               ((∃ id oiPP rkPP #x.
                  VerifiedAuthorityEndorsement( id, oi, rk_false, oiPP, rkPP ) @ #x) ∨
                (∃ id #x. VerifiedRootEndorsement( id, oi, rk_false ) @ #x))) ∧
              (¬(rk_true = rk_false))) ∧
             (CASk( ca, caSk ) @ #t3)) ∧
            (LogSk( log, logSk ) @ #t4)) ∧
           (certBody = <'cert', ca, <oi, sha256(rk_false)>, tlsPk>)) ∧
          (certSig = sign(certBody, caSk))) ∧
         (RootCertVerified( <certBody, certSig> ) @ #t5)) ∧
        (sctBody = <'sct', certBody>)) ∧
       (sctSig = sign(sctBody, logSk))) ∧
      (RootSCTVerified( <sctBody, sctSig> ) @ #t6)) ∧
     ((¬(∃ #a. LogInclusion( log, certBody ) @ #a)) ∨
      (¬(∃ #a. SignatureStore( log, certSig ) @ #a)))) ⇒
    (∃ #a. CompromisedParty( log ) @ #a)"
/*
guarded formula characterizing all counter-examples:
"∃ p oi rk_true rk_false ca caSk log logSk certBody tlsPk certSig sctBody
   sctSig #t1 #t3 #t4 #t5 #t6.
  (IsRootPK( p, oi, rk_true ) @ #t1) ∧
  (CASk( ca, caSk ) @ #t3) ∧
  (LogSk( log, logSk ) @ #t4) ∧
  (certBody = <'cert', ca, <oi, sha256(rk_false)>, tlsPk>) ∧
  (certSig = sign(certBody, caSk)) ∧
  (RootCertVerified( <certBody, certSig> ) @ #t5) ∧
  (sctBody = <'sct', certBody>) ∧
  (sctSig = sign(sctBody, logSk)) ∧
  (RootSCTVerified( <sctBody, sctSig> ) @ #t6)
 ∧
  (((∃ id oiPP rkPP #x.
      (VerifiedAuthorityEndorsement( id, oi, rk_false, oiPP, rkPP ) @ #x)) ∨
    (∃ id #x. (VerifiedRootEndorsement( id, oi, rk_false ) @ #x)))) ∧
  (¬(rk_true = rk_false)) ∧
  (((∀ #a. (LogInclusion( log, certBody ) @ #a) ⇒ ⊥) ∨
    (∀ #a. (SignatureStore( log, certSig ) @ #a) ⇒ ⊥))) ∧
  (∀ #a. (CompromisedParty( log ) @ #a) ⇒ ⊥)"
*/
simplify
solve( RootDomains( $P, ~rootKey, oi, rootD ) ▶₁ #t1 )
  case RootSetupDomains
  solve( (∀ #a.
           (LogInclusion( $Log,
                          <'cert', $CA.1, <$OI, sha256(rk_false)>, pk(tlsSk.1)>
            ) @ #a)
          ⇒
           ⊥)  ∥
         (∀ #a.
           (SignatureStore( $Log,
                            sign(<'cert', $CA.1, <$OI, sha256(rk_false)>, pk(tlsSk.1)>, ~skCA.1)
            ) @ #a)
          ⇒
           ⊥) )
    case case_1
    solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                      pk(tlsSk.1)>,
                     skLog.1)
           ) @ #vk.34 )
      case FraudulentCertificate
      solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                        pk(tlsSk.1)>,
                       ~skLog)
             ) @ #vk.37 )
        case Submit
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~skLog ) @ #vk.39 )
          case LogCompromise
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~skLog ) ▶₀ #vr.6 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.3, $OI.1, ~skLog ) ▶₀ #vr.6 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~skLog ) ▶₀ #vr.10 )
          qed
        qed
      qed
    next
      case Submit
      solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                        pk(tlsSk.1)>,
                       ~skLog)
             ) @ #vk.38 )
        case Submit
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~skLog ) @ #vk.41 )
          case LogCompromise
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.6 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.2, $OI.1, ~skLog ) ▶₀ #vr.6 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.10 )
          qed
        qed
      qed
    next
      case c_sign
      solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                        pk(tlsSk.1)>,
                       ~skLog)
             ) @ #vk.37 )
        case Submit
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~skLog ) @ #vk.40 )
          case LogCompromise
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.3 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.2, $OI.1, ~skLog ) ▶₀ #vr.3 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.7 )
          qed
        qed
      qed
    qed
  next
    case case_2
    solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                      pk(tlsSk.1)>,
                     skLog.1)
           ) @ #vk.34 )
      case FraudulentCertificate
      solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                        pk(tlsSk.1)>,
                       ~skLog)
             ) @ #vk.37 )
        case Submit
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~skLog ) @ #vk.39 )
          case LogCompromise
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~skLog ) ▶₀ #vr.6 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.3, $OI.1, ~skLog ) ▶₀ #vr.6 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.3, fst($OI.1), ~skLog ) ▶₀ #vr.10 )
          qed
        qed
      qed
    next
      case Submit
      solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                        pk(tlsSk.1)>,
                       ~skLog)
             ) @ #vk.38 )
        case Submit
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~skLog ) @ #vk.41 )
          case LogCompromise
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.6 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.2, $OI.1, ~skLog ) ▶₀ #vr.6 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.10 )
          qed
        qed
      qed
    next
      case c_sign
      solve( !KU( sign(<'sct', 'cert', $CA.1, <$OI, sha256(rk_false)>, 
                        pk(tlsSk.1)>,
                       ~skLog)
             ) @ #vk.37 )
        case Submit
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~skLog ) @ #vk.40 )
          case LogCompromise
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.3 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.2, $OI.1, ~skLog ) ▶₀ #vr.3 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~skLog ) ▶₀ #vr.7 )
          qed
        qed
      qed
    qed
  qed
qed

lemma AuthorityAccountability:
  all-traces
  "∀ p pAuth oi rk_true rk_false id oiAuth rkAuth #t1 #t2 #t3.
    ((((IsRootPK( p, oi, rk_true ) @ #t1) ∧
       (IsRootPK( pAuth, oiAuth, rkAuth ) @ #t2)) ∧
      (VerifiedAuthorityEndorsement( id, oiAuth, rkAuth, oi, rk_false
       ) @ #t3)) ∧
     (¬(rk_true = rk_false))) ⇒
    (∃ #a. CompromisedParty( pAuth ) @ #a)"
/*
guarded formula characterizing all counter-examples:
"∃ p pAuth oi rk_true rk_false id oiAuth rkAuth #t1 #t2 #t3.
  (IsRootPK( p, oi, rk_true ) @ #t1) ∧
  (IsRootPK( pAuth, oiAuth, rkAuth ) @ #t2) ∧
  (VerifiedAuthorityEndorsement( id, oiAuth, rkAuth, oi, rk_false ) @ #t3)
 ∧
  (¬(rk_true = rk_false)) ∧ (∀ #a. (CompromisedParty( pAuth ) @ #a) ⇒ ⊥)"
*/
simplify
solve( RootDomains( $P, ~rootKey, oi, rootD ) ▶₁ #t1 )
  case RootSetupDomains
  solve( RootDomains( $P.1, ~rootKey.1, oiAuth, rootD ) ▶₁ #t2 )
    case RootSetupDomains
    solve( !TLSKey( $P, $CA, $OI, tlsSk ) ▶₂ #t1 )
      case TLSKeyRegister
      solve( VerifyAuthoritySetup( ~id, ~sess, $OI.1, pk(~rootKey.1), $OI,
                                   pk(x), $E
             ) ▶₀ #t3 )
        case ReceiveAuthorityEndorsement_case_1
        solve( !KU( sign(<'end_ext', $OI.1, $OI, pk(x)>, ~rootKey.1) ) @ #vk.60 )
          case EndorseParty_case_1
          by contradiction /* from formulas */
        next
          case EndorseParty_case_2
          by contradiction /* from formulas */
        next
          case EndorseParty_case_3
          by contradiction /* from formulas */
        next
          case c_sign
          solve( !KU( ~rootKey.1 ) @ #vk.68 )
            case Reveal
            by contradiction /* from formulas */
          next
            case TLSKeyLeak_case_1
            by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.12 )
          next
            case TLSKeyLeak_case_2
            solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey.1 ) ▶₀ #vr.12 )
              case TLSKeyShare
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.16 )
            qed
          qed
        qed
      next
        case ReceiveAuthorityEndorsement_case_2
        solve( !KU( sign(<'end_ext', $OI.1, $OI, pk(x)>, ~rootKey.1) ) @ #vk.53 )
          case EndorseParty_case_1
          by contradiction /* from formulas */
        next
          case EndorseParty_case_2
          by contradiction /* from formulas */
        next
          case EndorseParty_case_3
          by contradiction /* from formulas */
        next
          case c_sign
          solve( !KU( ~rootKey.1 ) @ #vk.54 )
            case Reveal
            by contradiction /* from formulas */
          next
            case TLSKeyLeak_case_1
            by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.11 )
          next
            case TLSKeyLeak_case_2
            solve( !TLSKey( $A, $CA.3, $OI.2, ~rootKey.1 ) ▶₀ #vr.11 )
              case TLSKeyShare
              by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.15 )
            qed
          qed
        qed
      qed
    next
      case TLSKeyShare
      solve( VerifyAuthoritySetup( ~id, ~sess, $OI.1, pk(~rootKey.1), $OI,
                                   pk(x), $E
             ) ▶₀ #t3 )
        case ReceiveAuthorityEndorsement_case_1
        solve( !KU( sign(<'end_ext', $OI.1, $OI, pk(x)>, ~rootKey.1) ) @ #vk.60 )
          case EndorseParty_case_1
          by contradiction /* from formulas */
        next
          case EndorseParty_case_2
          by contradiction /* from formulas */
        next
          case EndorseParty_case_3
          by contradiction /* from formulas */
        next
          case EndorseParty_case_4
          by contradiction /* from formulas */
        next
          case EndorseParty_case_5
          by contradiction /* from formulas */
        next
          case EndorseParty_case_6
          by contradiction /* from formulas */
        next
          case c_sign
          solve( !KU( ~rootKey.1 ) @ #vk.68 )
            case Reveal
            by contradiction /* from formulas */
          next
            case TLSKeyLeak_case_1
            by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.11 )
          next
            case TLSKeyLeak_case_2
            solve( !TLSKey( $A, $CA.4, $OI.2, ~rootKey.1 ) ▶₀ #vr.11 )
              case TLSKeyShare
              by solve( !TLSKey( $A, $CA.4, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.15 )
            qed
          qed
        qed
      next
        case ReceiveAuthorityEndorsement_case_2
        solve( !KU( sign(<'end_ext', $OI.1, $OI, pk(x)>, ~rootKey.1) ) @ #vk.53 )
          case EndorseParty_case_1
          by contradiction /* from formulas */
        next
          case EndorseParty_case_2
          by contradiction /* from formulas */
        next
          case EndorseParty_case_3
          by contradiction /* from formulas */
        next
          case EndorseParty_case_4
          by contradiction /* from formulas */
        next
          case EndorseParty_case_5
          by contradiction /* from formulas */
        next
          case EndorseParty_case_6
          by contradiction /* from formulas */
        next
          case c_sign
          solve( !KU( ~rootKey.1 ) @ #vk.54 )
            case Reveal
            by contradiction /* from formulas */
          next
            case TLSKeyLeak_case_1
            by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.10 )
          next
            case TLSKeyLeak_case_2
            solve( !TLSKey( $A, $CA.3, $OI.2, ~rootKey.1 ) ▶₀ #vr.10 )
              case TLSKeyShare
              by solve( !TLSKey( $A, $CA.3, fst($OI.2), ~rootKey.1 ) ▶₀ #vr.14 )
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma PPAccountability:
  all-traces
  "∀ p oi rk e1 assetKey id #t1 #t2 #t3.
    ((((IsRootPK( p, oi, rk ) @ #t1) ∧
       (VerifiedRootEndorsement( id, oi, rk ) @ #t2)) ∧
      (VerifiedEndorsed( id, oi, e1, assetKey ) @ #t3)) ∧
     (¬(∃ e2 #x. IsAsset( p, e2, assetKey ) @ #x))) ⇒
    (∃ #a. CompromisedParty( p ) @ #a)"
/*
guarded formula characterizing all counter-examples:
"∃ p oi rk e1 assetKey id #t1 #t2 #t3.
  (IsRootPK( p, oi, rk ) @ #t1) ∧
  (VerifiedRootEndorsement( id, oi, rk ) @ #t2) ∧
  (VerifiedEndorsed( id, oi, e1, assetKey ) @ #t3)
 ∧
  (∀ e2 #x. (IsAsset( p, e2, assetKey ) @ #x) ⇒ ⊥) ∧
  (∀ #a. (CompromisedParty( p ) @ #a) ⇒ ⊥)"
*/
simplify
solve( RootDomains( $P, ~rootKey, oi, rootD ) ▶₁ #t1 )
  case RootSetupDomains
  solve( VerifyEndorsements( ~id, ~sess, $OI, $E, epk ) ▶₀ #t2 )
    case ReceiveEmblem
    solve( !TLSKey( $P, $CA, $OI, tlsSk ) ▶₂ #t1 )
      case TLSKeyRegister
      solve( !KU( sign(<'end_int', $OI, pk(x)>, ~rootKey) ) @ #vk.30 )
        case EndorseAsset
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~rootKey ) @ #vk.38 )
          case Reveal
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~rootKey ) ▶₀ #vr.7 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.2, $OI.1, ~rootKey ) ▶₀ #vr.7 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~rootKey ) ▶₀ #vr.11 )
          qed
        qed
      qed
    next
      case TLSKeyShare
      solve( !KU( sign(<'end_int', $OI, pk(x)>, ~rootKey) ) @ #vk.30 )
        case EndorseAsset_case_1
        by contradiction /* from formulas */
      next
        case EndorseAsset_case_2
        by contradiction /* from formulas */
      next
        case c_sign
        solve( !KU( ~rootKey ) @ #vk.38 )
          case Reveal
          by contradiction /* from formulas */
        next
          case TLSKeyLeak_case_1
          by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~rootKey ) ▶₀ #vr.6 )
        next
          case TLSKeyLeak_case_2
          solve( !TLSKey( $A, $CA.2, $OI.1, ~rootKey ) ▶₀ #vr.6 )
            case TLSKeyShare
            by solve( !TLSKey( $A, $CA.2, fst($OI.1), ~rootKey ) ▶₀ #vr.10 )
          qed
        qed
      qed
    qed
  qed
qed

lemma RootKeyUse:
  all-traces
  "∀ oi rk #t.
    (UsedRootKey( oi, rk ) @ #t) ⇒
    (∃ log logSk sctBody sctSig ca tlsPk #x #y.
      (((LogSk( log, logSk ) @ #x) ∧
        (sctBody = <'sct', 'cert', ca, <oi, sha256(rk)>, tlsPk>)) ∧
       (sctSig = sign(sctBody, logSk))) ∧
      (RootSCTVerified( <sctBody, sctSig> ) @ #y))"
/*
guarded formula characterizing all counter-examples:
"∃ oi rk #t.
  (UsedRootKey( oi, rk ) @ #t)
 ∧
  ∀ log logSk sctBody sctSig ca tlsPk #x #y.
   (LogSk( log, logSk ) @ #x) ∧
   (sctBody = <'sct', 'cert', ca, <oi, sha256(rk)>, tlsPk>) ∧
   (sctSig = sign(sctBody, logSk)) ∧
   (RootSCTVerified( <sctBody, sctSig> ) @ #y)
  ⇒
   ⊥"
*/
simplify
solve( UsedRootKey( oi, rk ) @ #t )
  case AuthoritySetupVerified
  solve( RootKeyResponse( ~sess, oi, rk ) ▶₁ #t )
    case RootKeyLearn_case_01
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_02
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_03
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_04
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_05
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_06
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_07
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_08
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_09
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_10
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_11
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_12
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_13
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_14
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_15
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_16
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_17
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_18
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_19
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_20
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_21
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_22
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_23
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_24
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_25
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_26
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_27
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_28
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_29
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_30
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_31
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_32
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_33
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_34
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_35
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_36
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_37
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_38
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_39
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_40
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_41
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_42
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_43
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_44
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_45
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_46
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_47
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_48
    by contradiction /* from formulas */
  qed
next
  case ReceiveInternalEndorsement
  solve( RootKeyResponse( ~sess, oi, pk(x) ) ▶₁ #t )
    case RootKeyLearn_case_01
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_02
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_03
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_04
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_05
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_06
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_07
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_08
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_09
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_10
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_11
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_12
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_13
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_14
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_15
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_16
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_17
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_18
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_19
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_20
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_21
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_22
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_23
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_24
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_25
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_26
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_27
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_28
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_29
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_30
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_31
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_32
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_33
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_34
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_35
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_36
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_37
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_38
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_39
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_40
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_41
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_42
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_43
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_44
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_45
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_46
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_47
    by contradiction /* from formulas */
  next
    case RootKeyLearn_case_48
    by contradiction /* from formulas */
  qed
qed

restriction Eq:
  "∀ a b #i. (Eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction Neq:
  "∀ a b #i. (Neq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction OnlyOnce:
  "∀ #i #j a. ((OnlyOnce( a ) @ #i) ∧ (OnlyOnce( a ) @ #j)) ⇒ (#i = #j)"
  // safety formula

/* All well-formedness checks were successful. */

end